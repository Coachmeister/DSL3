/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.math.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.math.*
import java.util.HashMap
import java.util.Map

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, String> variables;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        val math = resource.allContents.filter(MathExp).next
        generateMathFile(math, "math_expression", fsa)
    }

    def generateMathFile(MathExp math, String pkgName, IFileSystemAccess2 fsa2) {
        fsa2.generateFile(pkgName + "/" + math.name + ".java", GenJF(math))
    }
	
	def GenJF(MathExp exp) {
		return '''
package math_expression;
public class «exp.name» {
	«exp.genVars»
	«exp.genCompute»
	
	«exp.genExternal»
}
'''
	}
	
def String genVars(MathExp exp) {
		return '''
«FOR v : exp.variables»
public int «v.name»;
«ENDFOR»
'''
	}
	
	def String genCompute(MathExp exp) {
		exp.compute()
		
		return '''
public void compute() {
	«FOR v : exp.variables»
	«v.name» = «v.computeExpression»;
	«ENDFOR»
}
'''
	}
	
	def String genExternal(MathExp exp) {
		return '''
«IF exp.externals.size > 0»
private External external;
  
public «exp.name»(External external) {
	this.external = external;
}
interface External {
	«FOR func : exp.externals»
		int «func.name»(«func.genExt»);
	«ENDFOR»
}
«ENDIF»
'''
	}
	
	def String genExt(Ext ext) {
		switch (ext.parameters.size) {
			case 1: {
				return "int a" 
			}
			case 2: {
				return "int a, int b";
			}
			default: {
				return "";
			}
		}
	}
		
	def static compute(MathExp math) {
		variables = new HashMap()
		for(varBinding: math.variables)
			varBinding.computeExpression()
		variables
	}

	def static dispatch String computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return variables.get(binding.name)
	}

	def static dispatch String computeExpression(MathNumber exp) {
		exp.value.toString
	}
	def static dispatch String computeExpression(Plus exp) {
		exp.left.computeExpression + ' + ' + exp.right.computeExpression
	}

	def static dispatch String computeExpression(Minus exp) {
		exp.left.computeExpression + ' - ' + exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Mult exp) {
		exp.left.computeExpression + ' * ' + exp.right.computeExpression
	}
	
	def static dispatch String computeExpression(Div exp) {
		exp.left.computeExpression + ' / ' + exp.right.computeExpression
	}

	def static dispatch String computeExpression(LetBinding exp) {
		"(" + exp.body.computeExpression + ")"
	}

	def static dispatch String computeExpression(VariableUse exp) {
		"(" + exp.ref.computeBinding + ")"
	}
	
	def static dispatch String computeExpression(Par exp){
		"(" + exp.exp.computeExpression + " )"
	}

	def static dispatch String computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression()			
		variables.get(binding.name)
	}

	def static dispatch String computeBinding(LetBinding binding){
		"(" + binding.binding.computeExpression + ")"
	}
	
	def static dispatch String computeExpression(ExternalP exp){
		if(exp.args.size > 0){
			return '''
			this.external.«exp.ref.name»(«FOR x : exp.args SEPARATOR ', '»«x.computeExpression»«ENDFOR»)
			'''
		}else{
			return '''this.external.«exp.ref.name»()'''
		}
	}
}
